/*
 * This file was automatically generated by EvoSuite
 * Thu Mar 19 17:38:20 KST 2020
 */

package org.apache.commons.pool2;

import static org.evosuite.runtime.EvoAssertions.verifyException;
import static org.evosuite.shaded.org.mockito.Mockito.CALLS_REAL_METHODS;
import static org.evosuite.shaded.org.mockito.Mockito.doReturn;
import static org.evosuite.shaded.org.mockito.Mockito.mock;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import java.io.PrintWriter;
import java.lang.ref.ReferenceQueue;
import java.lang.ref.SoftReference;
import java.util.ArrayDeque;
import java.util.Deque;
import java.util.LinkedList;

import org.apache.commons.pool2.impl.DefaultPooledObject;
import org.apache.commons.pool2.impl.PooledSoftReference;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.junit.Test;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(useVNET = true, separateClassLoader = true, useJEE = true) 
public class PooledObject_ESTest extends PooledObject_ESTest_scaffolding {

  @Test(timeout = 4000)
  public void test00()  throws Throwable  {
      Object object0 = new Object();
      DefaultPooledObject<Object> defaultPooledObject0 = new DefaultPooledObject<Object>(object0);
      ReferenceQueue<Object> referenceQueue0 = new ReferenceQueue<Object>();
      SoftReference<Object> softReference0 = new SoftReference<Object>(defaultPooledObject0, referenceQueue0);
      PooledSoftReference<Object> pooledSoftReference0 = new PooledSoftReference<Object>(softReference0);
      pooledSoftReference0.getObject();
      pooledSoftReference0.getLastBorrowTime();
      DefaultPooledObject<PooledObject<Object>> defaultPooledObject1 = new DefaultPooledObject<PooledObject<Object>>(pooledSoftReference0);
      SoftReference<DefaultPooledObject<PooledObject<Object>>> softReference1 = new SoftReference<DefaultPooledObject<PooledObject<Object>>>(defaultPooledObject1, referenceQueue0);
      PooledSoftReference<DefaultPooledObject<PooledObject<Object>>> pooledSoftReference1 = new PooledSoftReference<DefaultPooledObject<PooledObject<Object>>>(softReference1);
      softReference0.clear();
      referenceQueue0.poll();
      DefaultPooledObject<PooledObject<Object>> defaultPooledObject2 = pooledSoftReference1.getObject();
      PooledSoftReference<DefaultPooledObject<PooledObject<Object>>> pooledSoftReference2 = new PooledSoftReference<DefaultPooledObject<PooledObject<Object>>>(softReference1);
      pooledSoftReference1.compareTo((PooledObject<DefaultPooledObject<PooledObject<Object>>>) pooledSoftReference2);
      softReference1.enqueue();
      pooledSoftReference1.allocate();
      pooledSoftReference0.getActiveTimeMillis();
      pooledSoftReference0.getLastReturnTime();
      defaultPooledObject2.allocate();
      defaultPooledObject2.setRequireFullStackTrace(true);
      defaultPooledObject2.getIdleTimeMillis();
      defaultPooledObject2.getBorrowedCount();
      DefaultPooledObject<PooledSoftReference<Object>> defaultPooledObject3 = new DefaultPooledObject<PooledSoftReference<Object>>(pooledSoftReference0);
      defaultPooledObject3.startEvictionTest();
      defaultPooledObject0.use();
      defaultPooledObject2.use();
      // Undeclared exception!
      try { 
        pooledSoftReference0.toString();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.apache.commons.pool2.impl.PooledSoftReference", e);
      }
  }

  @Test(timeout = 4000)
  public void test01()  throws Throwable  {
      Integer integer0 = new Integer(1393);
      DefaultPooledObject<Object> defaultPooledObject0 = new DefaultPooledObject<Object>(integer0);
      SoftReference<Object> softReference0 = new SoftReference<Object>(defaultPooledObject0);
      PooledSoftReference<Object> pooledSoftReference0 = new PooledSoftReference<Object>(softReference0);
      pooledSoftReference0.use();
      pooledSoftReference0.getObject();
      pooledSoftReference0.invalidate();
      ReferenceQueue<String> referenceQueue0 = new ReferenceQueue<String>();
      SoftReference<String> softReference1 = new SoftReference<String>("<Q?eb6Zt0Ado>|]O", referenceQueue0);
      softReference1.enqueue();
      PooledSoftReference<String> pooledSoftReference1 = new PooledSoftReference<String>(softReference1);
      pooledSoftReference1.getObject();
      ReferenceQueue<PooledObject<Object>> referenceQueue1 = new ReferenceQueue<PooledObject<Object>>();
      SoftReference<PooledObject<Object>> softReference2 = new SoftReference<PooledObject<Object>>(pooledSoftReference0, referenceQueue1);
      softReference0.clear();
      referenceQueue1.remove((long) 1393);
      softReference2.get();
      PooledSoftReference<PooledObject<Object>> pooledSoftReference2 = new PooledSoftReference<PooledObject<Object>>(softReference2);
      pooledSoftReference2.setLogAbandoned(false);
      pooledSoftReference1.getIdleTimeMillis();
      boolean boolean0 = pooledSoftReference2.deallocate();
      assertFalse(boolean0);
  }

  @Test(timeout = 4000)
  public void test02()  throws Throwable  {
      SoftReference<String> softReference0 = new SoftReference<String>("");
      PooledSoftReference<String> pooledSoftReference0 = new PooledSoftReference<String>(softReference0);
      pooledSoftReference0.invalidate();
      pooledSoftReference0.getObject();
      DefaultPooledObject<Object> defaultPooledObject0 = new DefaultPooledObject<Object>("");
      pooledSoftReference0.markAbandoned();
      softReference0.clear();
      pooledSoftReference0.setLogAbandoned(false);
      defaultPooledObject0.invalidate();
      defaultPooledObject0.markAbandoned();
      defaultPooledObject0.invalidate();
      Integer integer0 = new Integer(5);
      DefaultPooledObject<Integer> defaultPooledObject1 = new DefaultPooledObject<Integer>(integer0);
      Integer integer1 = new Integer((-77));
      DefaultPooledObject<Integer> defaultPooledObject2 = new DefaultPooledObject<Integer>(integer1);
      defaultPooledObject2.setRequireFullStackTrace(false);
      defaultPooledObject1.compareTo((PooledObject<Integer>) defaultPooledObject2);
      ReferenceQueue<Object> referenceQueue0 = new ReferenceQueue<Object>();
      SoftReference<Object> softReference1 = new SoftReference<Object>((Object) null, referenceQueue0);
      PooledSoftReference<Object> pooledSoftReference1 = new PooledSoftReference<Object>(softReference1);
      DefaultPooledObject<PooledObject<Object>> defaultPooledObject3 = new DefaultPooledObject<PooledObject<Object>>(pooledSoftReference1);
      defaultPooledObject3.markReturning();
      defaultPooledObject3.markReturning();
      defaultPooledObject2.equals("");
      pooledSoftReference0.getActiveTimeMillis();
      DefaultPooledObject<DefaultPooledObject<Object>> defaultPooledObject4 = new DefaultPooledObject<DefaultPooledObject<Object>>(defaultPooledObject0);
      defaultPooledObject4.endEvictionTest((Deque<PooledObject<DefaultPooledObject<Object>>>) null);
      SoftReference<Integer> softReference2 = new SoftReference<Integer>(integer0);
      PooledSoftReference<Integer> pooledSoftReference2 = new PooledSoftReference<Integer>(softReference2);
      DefaultPooledObject<DefaultPooledObject<Integer>> defaultPooledObject5 = new DefaultPooledObject<DefaultPooledObject<Integer>>(pooledSoftReference2);
      defaultPooledObject5.setLogAbandoned(false);
      assertEquals(PooledObjectState.IDLE, defaultPooledObject5.getState());
  }

  @Test(timeout = 4000)
  public void test03()  throws Throwable  {
      Integer integer0 = new Integer((-1604));
      DefaultPooledObject<Object> defaultPooledObject0 = new DefaultPooledObject<Object>(integer0);
      defaultPooledObject0.startEvictionTest();
      defaultPooledObject0.getActiveTimeMillis();
      DefaultPooledObject<DefaultPooledObject<Object>> defaultPooledObject1 = new DefaultPooledObject<DefaultPooledObject<Object>>(defaultPooledObject0);
      defaultPooledObject1.setLogAbandoned(true);
      defaultPooledObject1.equals(defaultPooledObject0);
      Integer integer1 = new Integer((-3210));
      DefaultPooledObject<Integer> defaultPooledObject2 = new DefaultPooledObject<Integer>(integer1);
      defaultPooledObject2.allocate();
      defaultPooledObject0.getLastBorrowTime();
      DefaultPooledObject<PooledObject<Integer>> defaultPooledObject3 = new DefaultPooledObject<PooledObject<Integer>>(defaultPooledObject2);
      defaultPooledObject3.getObject();
      defaultPooledObject2.getLastUsedTime();
      DefaultPooledObject<DefaultPooledObject<Integer>> defaultPooledObject4 = new DefaultPooledObject<DefaultPooledObject<Integer>>(defaultPooledObject2);
      defaultPooledObject4.allocate();
      defaultPooledObject4.getLastBorrowTime();
      PooledSoftReference<String> pooledSoftReference0 = new PooledSoftReference<String>((SoftReference<String>) null);
      // Undeclared exception!
      try { 
        pooledSoftReference0.getObject();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.apache.commons.pool2.impl.PooledSoftReference", e);
      }
  }

  @Test(timeout = 4000)
  public void test04()  throws Throwable  {
      DefaultPooledObject<Integer> defaultPooledObject0 = new DefaultPooledObject<Integer>((Integer) null);
      defaultPooledObject0.use();
      SoftReference<Object> softReference0 = new SoftReference<Object>((Object) null);
      PooledSoftReference<Object> pooledSoftReference0 = new PooledSoftReference<Object>(softReference0);
      DefaultPooledObject<PooledSoftReference<Object>> defaultPooledObject1 = new DefaultPooledObject<PooledSoftReference<Object>>(pooledSoftReference0);
      pooledSoftReference0.markAbandoned();
      defaultPooledObject1.allocate();
      softReference0.get();
      defaultPooledObject1.startEvictionTest();
      pooledSoftReference0.setRequireFullStackTrace(false);
      LinkedList<PooledObject<Integer>> linkedList0 = new LinkedList<PooledObject<Integer>>();
      defaultPooledObject0.endEvictionTest(linkedList0);
      defaultPooledObject0.getBorrowedCount();
      PooledSoftReference<DefaultPooledObject<String>> pooledSoftReference1 = new PooledSoftReference<DefaultPooledObject<String>>((SoftReference<DefaultPooledObject<String>>) null);
      ArrayDeque<PooledObject<DefaultPooledObject<String>>> arrayDeque0 = new ArrayDeque<PooledObject<DefaultPooledObject<String>>>();
      pooledSoftReference1.endEvictionTest(arrayDeque0);
      pooledSoftReference1.allocate();
      pooledSoftReference1.markAbandoned();
      DefaultPooledObject<PooledObject<Object>> defaultPooledObject2 = new DefaultPooledObject<PooledObject<Object>>(pooledSoftReference0);
      defaultPooledObject2.getState();
      DefaultPooledObject<String> defaultPooledObject3 = new DefaultPooledObject<String>("1gx&&0NtlM_");
      long long0 = defaultPooledObject3.getActiveTimeMillis();
      assertEquals(0L, long0);
  }

  @Test(timeout = 4000)
  public void test05()  throws Throwable  {
      Integer integer0 = new Integer((-2226));
      DefaultPooledObject<Object> defaultPooledObject0 = new DefaultPooledObject<Object>(integer0);
      ReferenceQueue<Object> referenceQueue0 = new ReferenceQueue<Object>();
      SoftReference<Object> softReference0 = new SoftReference<Object>(defaultPooledObject0, referenceQueue0);
      PooledSoftReference<Object> pooledSoftReference0 = new PooledSoftReference<Object>(softReference0);
      DefaultPooledObject<DefaultPooledObject<Object>> defaultPooledObject1 = new DefaultPooledObject<DefaultPooledObject<Object>>(pooledSoftReference0);
      pooledSoftReference0.getObject();
      defaultPooledObject1.markAbandoned();
      defaultPooledObject1.setLogAbandoned(true);
      pooledSoftReference0.startEvictionTest();
      SoftReference<PooledSoftReference<String>> softReference1 = new SoftReference<PooledSoftReference<String>>((PooledSoftReference<String>) null);
      softReference1.enqueue();
      softReference1.enqueue();
      PooledSoftReference<PooledSoftReference<String>> pooledSoftReference1 = new PooledSoftReference<PooledSoftReference<String>>(softReference1);
      // Undeclared exception!
      try { 
        pooledSoftReference1.toString();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.apache.commons.pool2.impl.PooledSoftReference", e);
      }
  }

  @Test(timeout = 4000)
  public void test06()  throws Throwable  {
      PooledSoftReference<Object> pooledSoftReference0 = new PooledSoftReference<Object>((SoftReference<Object>) null);
      DefaultPooledObject<Object> defaultPooledObject0 = new DefaultPooledObject<Object>(pooledSoftReference0);
      PooledObjectState pooledObjectState0 = defaultPooledObject0.getState();
      assertEquals(PooledObjectState.IDLE, pooledObjectState0);
  }

  @Test(timeout = 4000)
  public void test07()  throws Throwable  {
      DefaultPooledObject<String> defaultPooledObject0 = new DefaultPooledObject<String>("JwfcP^Z*p??k:'1");
      defaultPooledObject0.startEvictionTest();
      defaultPooledObject0.getLastUsedTime();
      defaultPooledObject0.getCreateTime();
      ReferenceQueue<Object> referenceQueue0 = new ReferenceQueue<Object>();
      SoftReference<Object> softReference0 = new SoftReference<Object>("JwfcP^Z*p??k:'1", referenceQueue0);
      softReference0.clear();
      softReference0.enqueue();
      PooledSoftReference<Object> pooledSoftReference0 = new PooledSoftReference<Object>(softReference0);
      // Undeclared exception!
      try { 
        pooledSoftReference0.toString();
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.apache.commons.pool2.impl.PooledSoftReference", e);
      }
  }

  @Test(timeout = 4000)
  public void test08()  throws Throwable  {
      ReferenceQueue<Object> referenceQueue0 = new ReferenceQueue<Object>();
      SoftReference<Object> softReference0 = new SoftReference<Object>((Object) null, referenceQueue0);
      PooledSoftReference<Object> pooledSoftReference0 = new PooledSoftReference<Object>(softReference0);
      DefaultPooledObject<PooledObject<Object>> defaultPooledObject0 = new DefaultPooledObject<PooledObject<Object>>(pooledSoftReference0);
      long long0 = defaultPooledObject0.getActiveTimeMillis();
      assertEquals(0L, long0);
  }

  @Test(timeout = 4000)
  public void test09()  throws Throwable  {
      Integer integer0 = new Integer((-2211));
      DefaultPooledObject<Object> defaultPooledObject0 = new DefaultPooledObject<Object>(integer0);
      defaultPooledObject0.getObject();
      long long0 = defaultPooledObject0.getLastUsedTime();
      defaultPooledObject0.invalidate();
      ArrayDeque<PooledObject<Object>> arrayDeque0 = new ArrayDeque<PooledObject<Object>>();
      arrayDeque0.add(defaultPooledObject0);
      defaultPooledObject0.endEvictionTest(arrayDeque0);
      long long1 = defaultPooledObject0.getBorrowedCount();
      assertFalse(long1 == long0);
  }

  @Test(timeout = 4000)
  public void test10()  throws Throwable  {
      PooledSoftReference<DefaultPooledObject<Object>> pooledSoftReference0 = new PooledSoftReference<DefaultPooledObject<Object>>((SoftReference<DefaultPooledObject<Object>>) null);
      pooledSoftReference0.allocate();
      pooledSoftReference0.printStackTrace((PrintWriter) null);
      pooledSoftReference0.setRequireFullStackTrace(true);
      pooledSoftReference0.markReturning();
      pooledSoftReference0.getIdleTimeMillis();
      long long0 = pooledSoftReference0.getCreateTime();
      PooledSoftReference<String> pooledSoftReference1 = new PooledSoftReference<String>((SoftReference<String>) null);
      pooledSoftReference1.startEvictionTest();
      pooledSoftReference1.markAbandoned();
      DefaultPooledObject<PooledSoftReference<String>> defaultPooledObject0 = new DefaultPooledObject<PooledSoftReference<String>>(pooledSoftReference1);
      defaultPooledObject0.getObject();
      DefaultPooledObject<Object> defaultPooledObject1 = new DefaultPooledObject<Object>(defaultPooledObject0);
      long long1 = defaultPooledObject1.getLastReturnTime();
      //  // Unstable assertion: assertFalse(long1 == long0);
  }

  @Test(timeout = 4000)
  public void test11()  throws Throwable  {
      DefaultPooledObject<Object> defaultPooledObject0 = new DefaultPooledObject<Object>((Object) null);
      defaultPooledObject0.use();
      //  // Unstable assertion: assertEquals(1584607082725L, defaultPooledObject0.getCreateTime());
  }

  @Test(timeout = 4000)
  public void test12()  throws Throwable  {
      Object object0 = new Object();
      ReferenceQueue<Object> referenceQueue0 = new ReferenceQueue<Object>();
      SoftReference<Object> softReference0 = new SoftReference<Object>(object0, referenceQueue0);
      PooledSoftReference<Object> pooledSoftReference0 = new PooledSoftReference<Object>(softReference0);
      DefaultPooledObject<Object> defaultPooledObject0 = new DefaultPooledObject<Object>(pooledSoftReference0);
      defaultPooledObject0.setLogAbandoned(true);
      Integer integer0 = new Integer(894);
      softReference0.enqueue();
      DefaultPooledObject<Integer> defaultPooledObject1 = new DefaultPooledObject<Integer>(integer0);
      defaultPooledObject1.toString();
      DefaultPooledObject<DefaultPooledObject<Object>> defaultPooledObject2 = new DefaultPooledObject<DefaultPooledObject<Object>>(defaultPooledObject0);
      defaultPooledObject2.setLogAbandoned(true);
      pooledSoftReference0.markAbandoned();
      pooledSoftReference0.markReturning();
      DefaultPooledObject<String> defaultPooledObject3 = new DefaultPooledObject<String>("");
      defaultPooledObject3.getLastBorrowTime();
      defaultPooledObject1.getActiveTimeMillis();
      SoftReference<DefaultPooledObject<Object>> softReference1 = new SoftReference<DefaultPooledObject<Object>>(pooledSoftReference0);
      PooledSoftReference<DefaultPooledObject<Object>> pooledSoftReference1 = new PooledSoftReference<DefaultPooledObject<Object>>(softReference1);
      DefaultPooledObject<Object> defaultPooledObject4 = pooledSoftReference1.getObject();
      //  // Unstable assertion: assertEquals(2L, defaultPooledObject4.getIdleTimeMillis());
  }

  @Test(timeout = 4000)
  public void test13()  throws Throwable  {
      DefaultPooledObject<String> defaultPooledObject0 = new DefaultPooledObject<String>("");
      SoftReference<DefaultPooledObject<String>> softReference0 = new SoftReference<DefaultPooledObject<String>>(defaultPooledObject0);
      PooledSoftReference<DefaultPooledObject<String>> pooledSoftReference0 = new PooledSoftReference<DefaultPooledObject<String>>(softReference0);
      pooledSoftReference0.getLastUsedTime();
      pooledSoftReference0.markReturning();
      pooledSoftReference0.invalidate();
      LinkedList<PooledObject<String>> linkedList0 = new LinkedList<PooledObject<String>>();
      defaultPooledObject0.endEvictionTest(linkedList0);
      pooledSoftReference0.setRequireFullStackTrace(false);
      pooledSoftReference0.setRequireFullStackTrace(false);
      //  // Unstable assertion: assertEquals(1584607082710L, pooledSoftReference0.getLastReturnTime());
  }

  @Test(timeout = 4000)
  public void test14()  throws Throwable  {
      PooledObject<Object> pooledObject0 = (PooledObject<Object>) mock(PooledObject.class, CALLS_REAL_METHODS);
      doReturn(0L).when(pooledObject0).getIdleTimeMillis();
      doReturn((Object) null).when(pooledObject0).getObject();
      DefaultPooledObject<PooledObject<Object>> defaultPooledObject0 = new DefaultPooledObject<PooledObject<Object>>(pooledObject0);
      PooledObject<Object> pooledObject1 = defaultPooledObject0.getObject();
      defaultPooledObject0.toString();
      pooledObject1.getObject();
      SoftReference<DefaultPooledObject<PooledObject<Object>>> softReference0 = new SoftReference<DefaultPooledObject<PooledObject<Object>>>(defaultPooledObject0);
      defaultPooledObject0.setRequireFullStackTrace(true);
      softReference0.get();
      PooledSoftReference<DefaultPooledObject<PooledObject<Object>>> pooledSoftReference0 = new PooledSoftReference<DefaultPooledObject<PooledObject<Object>>>(softReference0);
      pooledSoftReference0.use();
      pooledSoftReference0.deallocate();
      pooledSoftReference0.markAbandoned();
      defaultPooledObject0.getLastUsedTime();
      Integer integer0 = new Integer((-220));
      ReferenceQueue<Object> referenceQueue0 = new ReferenceQueue<Object>();
      SoftReference<Object> softReference1 = new SoftReference<Object>(integer0, referenceQueue0);
      softReference1.get();
      PooledSoftReference<Object> pooledSoftReference1 = new PooledSoftReference<Object>(softReference1);
      ArrayDeque<PooledObject<Object>> arrayDeque0 = new ArrayDeque<PooledObject<Object>>();
      pooledSoftReference1.endEvictionTest(arrayDeque0);
      Integer integer1 = new Integer((-220));
      DefaultPooledObject<Integer> defaultPooledObject1 = new DefaultPooledObject<Integer>(integer1);
      defaultPooledObject1.getLastReturnTime();
      pooledObject1.getIdleTimeMillis();
      DefaultPooledObject<DefaultPooledObject<Object>> defaultPooledObject2 = new DefaultPooledObject<DefaultPooledObject<Object>>(pooledSoftReference1);
      PooledObjectState pooledObjectState0 = defaultPooledObject2.getState();
      assertEquals(PooledObjectState.IDLE, pooledObjectState0);
  }

  @Test(timeout = 4000)
  public void test15()  throws Throwable  {
      PooledSoftReference<PooledSoftReference<Object>> pooledSoftReference0 = new PooledSoftReference<PooledSoftReference<Object>>((SoftReference<PooledSoftReference<Object>>) null);
      pooledSoftReference0.markAbandoned();
      pooledSoftReference0.getReference();
      Integer integer0 = new Integer((-1858));
      DefaultPooledObject<Integer> defaultPooledObject0 = new DefaultPooledObject<Integer>(integer0);
      defaultPooledObject0.getBorrowedCount();
      defaultPooledObject0.getLastBorrowTime();
      defaultPooledObject0.allocate();
      defaultPooledObject0.setLogAbandoned(false);
      SoftReference<String> softReference0 = new SoftReference<String>("");
      PooledSoftReference<String> pooledSoftReference1 = new PooledSoftReference<String>(softReference0);
      PooledSoftReference<String> pooledSoftReference2 = new PooledSoftReference<String>(softReference0);
      pooledSoftReference2.getLastUsedTime();
      LinkedList<PooledObject<String>> linkedList0 = new LinkedList<PooledObject<String>>();
      boolean boolean0 = pooledSoftReference2.endEvictionTest(linkedList0);
      pooledSoftReference2.markReturning();
      pooledSoftReference1.compareTo((PooledObject<String>) pooledSoftReference2);
      pooledSoftReference0.allocate();
      pooledSoftReference1.getObject();
      Object object0 = new Object();
      defaultPooledObject0.equals(object0);
      DefaultPooledObject<Object> defaultPooledObject1 = new DefaultPooledObject<Object>("");
      defaultPooledObject1.invalidate();
      defaultPooledObject1.getIdleTimeMillis();
      SoftReference<Object> softReference1 = new SoftReference<Object>((Object) null, (ReferenceQueue<? super Object>) null);
      PooledSoftReference<Object> pooledSoftReference3 = new PooledSoftReference<Object>(softReference1);
      pooledSoftReference3.setReference(softReference1);
      LinkedList<PooledObject<Integer>> linkedList1 = new LinkedList<PooledObject<Integer>>();
      boolean boolean1 = defaultPooledObject0.endEvictionTest(linkedList1);
      assertTrue(boolean1 == boolean0);
  }
}
